//
// t370.cmm : 式の最適化テスト追加(2012.8.18)
//

int a,c;
public int d();
public int e(int a, int b);
void f() {
     int b;
     b=(2+3*a+1)*(3+4)*(4+4);         // b=(3*a+3)*56  (スタックが浅い
     b=(2+3*a+1)*(3+4)*(4*4);         // b=(3*a+3)*112  順でコード生成)
     b=3+a+4+5+6*(7+8);               // b=102+a
     b=4/a/(2+2-(2-2));               // b=1/a
     b=ord(4/a/(2+2-(2-2))>2/3/4);    // b=(1/a)>0
     b=1+a+(d()*(1-1)*10*20)+2;       // b=3+a
     b=ord(1+a>((b+4)+(c+6)));        // b=(1+a)>(b+10+c)
     b=b+1+a-(3<<1);                  // b=b+(-5)+a    ((-5)==65531)
     b=b+1+a-(3>>1);                  // b=b+a
     b=((1<<(16-1))|((1<<(16-1))-1)); // b=65535
     b=~0^((1<<(8-1))|((1<<(8-1))-1));// b=65280
     b=((1<<15)+(1<<15))/2;           // b=0(オーバーフローする)
     b=b/20/a/5;                      // b=b/100/a
     b=b-20-a-5+25;                   // b=b-a
     b=b+20-10-(3-2);                 // b=b+9
     b=((1<<(8-1)|((1<<(8-1))-1)));   // 0xff
     b=b*2;                           // shl
     b=2*b;                           // shl
     b=b/2;                           // shr
     b=b%2;                           // b=b&1

     b=b*1;                           // b=b
     b=1*b;                           // b=b
     b=b/1;                           // b=b
     b=b%1;                           // b=0

     boolean t;
     t=10>-1;                         // true(負の数を含む大小比較)
     t=(1>0) && t && (1>0);           // t=t
     t=!(1>0) || t || !(1>0);         // t=t

     e(1+a+2, 1*a*(1-1));	          // e(3+a, 0)
     while (1==0 || a<c) ;                // while (a<c) ;
     while (1==d()*(1-1)*10*20 || a<c) ;  // while (a<c) ;


// bool 演算子で true / false の判定をどうするか?
// 非ゼロ : true?
// 最下位ビットで判定?
//
// 最適化ルーチンは最下位ビット
// vmのコード生成はbool命令
// h8のコード生成は最下位ビット
     t = bool(a);

// char, bool が正しく扱えるか
     for (char c=chr(0); c=='a'; c=chr(ord(c)-1)) ;
     for (boolean c=bool(0); c==true; c=bool(ord(c)-1)) ;
}
